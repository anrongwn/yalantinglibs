<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.4"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="Doxygen Awesome"/>
    <meta property="og:image"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta property="og:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>
    <!-- END opengraph metadata -->
    <!-- BEGIN twitter metadata -->
    <meta name="twitter:image:src"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta name="twitter:title" content="Doxygen Awesome"/>
    <meta name="twitter:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <!-- END twitter metadata -->
    <title>yaLanTingLibs: struct_pack Introduction</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="toggle-alternative-theme.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/alibaba/yalantinglibs" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">yaLanTingLibs
                    </div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <!-- end header part -->
<!-- 制作者 Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src_struct_pack_doc__introduction_en.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">struct_pack Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目录</h3>
<ul><li class="level1"><a href="#autotoc_md24">Serialization</a><ul><li class="level2"><a href="#autotoc_md25">Basic Usage</a></li>
<li class="level2"><a href="#autotoc_md26">Explicit data container</a></li>
<li class="level2"><a href="#autotoc_md27">Append the result at the end of existing data container</a></li>
<li class="level2"><a href="#autotoc_md28">Save the results to memory location indicated by pointer</a></li>
<li class="level2"><a href="#autotoc_md29">Multi-parameter serialization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md30">Deserialization</a><ul><li class="level2"><a href="#autotoc_md31">Basic Usage</a></li>
<li class="level2"><a href="#autotoc_md32">deserialize from pointers</a></li>
<li class="level2"><a href="#autotoc_md33">deserialize to an existing object</a></li>
<li class="level2"><a href="#autotoc_md34">Multi-parameter deserialization</a></li>
<li class="level2"><a href="#autotoc_md35">Partial deserialization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md36">support std containers, std::optional and custom containers</a></li>
<li class="level1"><a href="#autotoc_md37">benchmark</a><ul><li class="level2"><a href="#autotoc_md38">Test case</a></li>
<li class="level2"><a href="#autotoc_md39">Test objects</a></li>
<li class="level2"><a href="#autotoc_md40">Test Environment</a></li>
<li class="level2"><a href="#autotoc_md41">Test results</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md42">Forward/backward compatibility</a></li>
<li class="level1"><a href="#autotoc_md43">Why is struct_pack faster?</a></li>
<li class="level1"><a href="#autotoc_md44">Appendix</a><ul><li class="level2"><a href="#autotoc_md45">Test code</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><ul>
<li>struct_pack Introduction<ul>
<li>Serialization<ul>
<li>Basic Usage</li>
<li>Explicit data container</li>
<li>Append the result at the end of existing data container</li>
<li>Save the results to memory location indicated by pointer</li>
<li>Multi-parameter serialization</li>
</ul>
</li>
<li>Deserialization<ul>
<li>Basic Usage</li>
<li>deserialize from pointers</li>
<li>deserialize to an existing object</li>
<li>Multi-parameter deserialization</li>
<li>Partial deserialization</li>
</ul>
</li>
<li>support std containers, std::optional and custom containers</li>
<li>benchmark<ul>
<li>Test case</li>
<li>Test objects</li>
<li>Test Environment</li>
<li>Test results</li>
</ul>
</li>
<li>Forward/backward compatibility</li>
<li>Why is struct_pack faster?</li>
<li>Appendix<ul>
<li>Test code</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >struct_pack is a serialization library featuring zero-cost abstraction as well as usability. In struct_pack, the serialization or deserialization of one complex structure could easily be done in a single line of code, without any DSL, macro, or template to be defined. struct_pack supports the serialization of C++ structures through compile-time reflection and its performance is significantly better than protobuf and msgpack (see the benchmark section for details).</p>
<p >Below, we show the basic usage of struct_pack with a simple object as an example.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct person {</div>
<div class="line">  int64_t id;</div>
<div class="line">  std::string name;</div>
<div class="line">  int age;</div>
<div class="line">  double salary;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">person person1{.id = 1, .name = &quot;hello struct pack&quot;, .age = 20, .salary = 1024.42};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Serialization</h1>
<p >In below we demonstrate serval ways of serialize one object with struct_pack APIs.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// serialization in one line</div>
<div class="line">std::vector&lt;char&gt; result = struct_pack::serialize(person1);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Explicit data container</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto result = struct_pack::serialize&lt;std::string&gt;(person1);</div>
<div class="line">// explicitly use std::string instead of std::vector&lt;char&gt; to hold the result</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Append the result at the end of existing data container</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::string result=&quot;The next line is struct_pack serialize result.\n&quot;;</div>
<div class="line">auto result = struct_pack::serialize_to(result,person1);</div>
<div class="line">// </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Save the results to memory location indicated by pointer</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto sz=struct_pack::get_needed_siarray(person1);</div>
<div class="line">std::unique_ptr array=std::make_unique&lt;char[]&gt;(sz);</div>
<div class="line">auto result = struct_pack::serialize_to(array.get(),sz,person1);</div>
<div class="line">// save the result at given memory location by pointer</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Multi-parameter serialization</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto result=struct_pack::serialize(person1.id, person1.name, person1.age, person1.salary);</div>
<div class="line">//serialize as std::tuple&lt;int64_t, std::string, int, double&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Deserialization</h1>
<p >In below we demonstrate serval ways of deserialize one object with struct_pack APIs.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// deserialize in one line</div>
<div class="line">auto person2 = deserialize&lt;person&gt;(buffer);</div>
<div class="line">assert(person2); // person2.has_value() == true</div>
<div class="line">assert(person2.value()==person1);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
deserialize from pointers</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// deserialize from memory location indicated by pointers</div>
<div class="line">auto person2 = deserialize&lt;person&gt;(buffer.data(),buffer.size());</div>
<div class="line">assert(person2); //person2.has_value() == true</div>
<div class="line">assert(person2.value()==person1);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
deserialize to an existing object</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// deserialize to an existing object</div>
<div class="line">person person2;</div>
<div class="line">std::errc ec = deserialize_to(person2, buffer);</div>
<div class="line">assert(ec==std::errc{}); // person2.has_value() == true</div>
<div class="line">assert(person2==person1);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Multi-parameter deserialization</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto person2 = deserialize&lt;int64_t,std::string,int,double&gt;(buffer);</div>
<div class="line">assert(person2); // person2.has_value() == true</div>
<div class="line">auto &amp;&amp;[id,name,age,salary]=person2.value();</div>
<div class="line">assert(person1.id==id);</div>
<div class="line">assert(person1.name==name);</div>
<div class="line">assert(person1.age==age);</div>
<div class="line">assert(person1.salary==salary);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Partial deserialization</h2>
<p >Sometimes users only need to deserialize specific fields of an object instead of all of them, and that's when the partial deserialization feature can be used. This can avoid full deserialization and improve efficiency significantly, eg.:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Just deserialize the 2nd field of person </div>
<div class="line">auto name = get_field&lt;person, 1&gt;(buffer.data(), buffer.size());</div>
<div class="line">assert(name); // name.has_value() == true</div>
<div class="line">assert(name.value() == &quot;hello struct pack&quot;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md36"></a>
support std containers, std::optional and custom containers</h1>
<p >For example, the library supports the following complicated objects with std containers and std::optional fields:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">enum class Color { red, black, white };</div>
<div class="line"> </div>
<div class="line">struct complicated_object {</div>
<div class="line">  Color color;</div>
<div class="line">  int a;</div>
<div class="line">  std::string b;</div>
<div class="line">  std::vector&lt;person&gt; c;</div>
<div class="line">  std::list&lt;std::string&gt; d;</div>
<div class="line">  std::deque&lt;int&gt; e;</div>
<div class="line">  std::map&lt;int, person&gt; f;</div>
<div class="line">  std::multimap&lt;int, person&gt; g;</div>
<div class="line">  std::set&lt;std::string&gt; h;</div>
<div class="line">  std::multiset&lt;int&gt; i;</div>
<div class="line">  std::unordered_map&lt;int, person&gt; j;</div>
<div class="line">  std::unordered_multimap&lt;int, int&gt; k;</div>
<div class="line">  std::array&lt;person, 2&gt; m;</div>
<div class="line">  person n[2];</div>
<div class="line">  std::pair&lt;std::string, person&gt; o;</div>
<div class="line">  std::optional&lt;int&gt; p;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct nested_object {</div>
<div class="line">  int id;</div>
<div class="line">  std::string name;</div>
<div class="line">  person p;</div>
<div class="line">  complicated_object o;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">nested_object nested{.id = 2, .name = &quot;tom&quot;, .p = {20, &quot;tom&quot;}, .o = {}};</div>
<div class="line">auto buffer = serialize(nested);</div>
<div class="line">auto nested2 = deserialize(buffer.data(), buffer.size());</div>
<div class="line">assert(nested2)</div>
<div class="line">assert(nested2==nested1);</div>
</div><!-- fragment --><p >In addition, struct_pack supports serialization and deserialization on custom containers, as below:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// We should not inherit from stl container, this case just for testing.</div>
<div class="line">template &lt;typename Key, typename Value&gt;</div>
<div class="line">struct my_map : public std::map&lt;Key, Value&gt; {};</div>
<div class="line"> </div>
<div class="line">my_map&lt;int, std::string&gt; map1;</div>
<div class="line">map1.emplace(1, &quot;tom&quot;);</div>
<div class="line">map1.emplace(2, &quot;jerry&quot;);</div>
<div class="line"> </div>
<div class="line">absl::flat_hash_map&lt;int, std::string&gt; map2 =</div>
<div class="line">    {{1, &quot;huey&quot;}, {2, &quot;dewey&quot;}, {3, &quot;louie&quot;},};</div>
<div class="line"> </div>
<div class="line">auto buffer1 = serialize(map1);</div>
<div class="line">auto buffer2 = serialize(map2);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
benchmark</h1>
<h2><a class="anchor" id="autotoc_md38"></a>
Test case</h2>
<p >The object to be serialized is pre-initialized and the memory to store the serialization result is pre-allocated. For each test case, we run one million serializations/deserialization and take the average.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Test objects</h2>
<ol type="1">
<li>A simple object <code>person</code> with 4 scaler types</li>
</ol>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct person {</div>
<div class="line">  int64_t id;</div>
<div class="line">  std::string name;</div>
<div class="line">  int age;</div>
<div class="line">  double salary;</div>
<div class="line">};</div>
</div><!-- fragment --><ol type="1">
<li>A complicated object <code>monster</code> with nested types</li>
</ol>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">enum Color : uint8_t { Red, Green, Blue };</div>
<div class="line"> </div>
<div class="line">struct Vec3 {</div>
<div class="line">  float x;</div>
<div class="line">  float y;</div>
<div class="line">  float z;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct Weapon {</div>
<div class="line">  std::string name;</div>
<div class="line">  int16_t damage;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct Monster {</div>
<div class="line">  Vec3 pos;</div>
<div class="line">  int16_t mana;</div>
<div class="line">  int16_t hp;</div>
<div class="line">  std::string name;</div>
<div class="line">  std::vector&lt;uint8_t&gt; inventory;</div>
<div class="line">  Color color;</div>
<div class="line">  std::vector&lt;Weapon&gt; weapons;</div>
<div class="line">  Weapon equipped;</div>
<div class="line">  std::vector&lt;Vec3&gt; path;</div>
<div class="line">};</div>
</div><!-- fragment --><ol type="1">
<li>A <code>rect</code> object with for <code>int32_t</code></li>
</ol>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct rect {</div>
<div class="line">  int32_t x;</div>
<div class="line">  int32_t y;</div>
<div class="line">  int32_t width;</div>
<div class="line">  int32_t height;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Test Environment</h2>
<p >Compiler: Alibaba Clang 13</p>
<p >Processor: (Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz)</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Test results</h2>
<div class="image">
<img src="struct_pack_bench.png" alt=""/>
</div>
    <h1><a class="anchor" id="autotoc_md42"></a>
Forward/backward compatibility</h1>
<p >If current message type no longer meets all you needs - say, you'd like the object to have an extra field, the compatibility should not be broken so that the old object could be correctly parsed with the new type definition. In struct_pack, any new fields you added must be of type <code>struct_pack::compatible&lt;T&gt;</code> and be appended <b>at the end of the object</b>. <br  />
Let's take struct <code>person</code> as an example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct person {</div>
<div class="line">  int age;</div>
<div class="line">  std::string name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct person1 {</div>
<div class="line">  int age;</div>
<div class="line">  std::string name;</div>
<div class="line">  struct_pack::compatible&lt;int32_t&gt; id;</div>
<div class="line">  struct_pack::compatible&lt;bool&gt; maybe;</div>
<div class="line">};</div>
</div><!-- fragment --><p >struct_pack ensures that the two classes can be safely converted to each other by serialization and deserialization, thus achieving forward/backward compatibility.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Why is struct_pack faster?</h1>
<ol type="1">
<li>Streamlined type information and efficient type-checking. MD5 computation is done at compile time so at runtime we only needs to compare 32bit hash values to check sameness.</li>
<li>struct_pack is a template library that encourages the compiler to do a better job at inlining.</li>
<li>Zero-cost abstraction, no runtime cost for features that are not used.</li>
<li>struct_pack's memory layout is much closer to the native C++ object, reducing the workload of (de)serializations.</li>
<li>Compile-time type calculation allows struct_pack to generate different codes according to different types. So we can do optimization upon types. For example, we could use <code>memcpy</code> on contiguous containers and zero-copy optimization could be used on <code>string_view</code></li>
</ol>
<h1><a class="anchor" id="autotoc_md44"></a>
Appendix</h1>
<h2><a class="anchor" id="autotoc_md45"></a>
Test code</h2>
<p >see <a href="../benchmark/benchmark.cpp">benchmark.cpp</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
