<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.4"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="Doxygen Awesome"/>
    <meta property="og:image"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta property="og:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>
    <!-- END opengraph metadata -->
    <!-- BEGIN twitter metadata -->
    <meta name="twitter:image:src"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta name="twitter:title" content="Doxygen Awesome"/>
    <meta name="twitter:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <!-- END twitter metadata -->
    <title>yaLanTingLibs: Introduction</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="toggle-alternative-theme.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/alibaba/yalantinglibs" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">yaLanTingLibs
                    </div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <!-- end header part -->
<!-- 制作者 Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src_coro_rpc_doc_coro_rpc_introduction_en.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目录</h3>
<ul><li class="level1"><a href="#autotoc_md65">Usability</a><ul><li class="level2"><a href="#autotoc_md66">server</a></li>
<li class="level2"><a href="#autotoc_md67">RPC with any parameters</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md68">Compare with grpc/brpc</a><ul><li class="level2"><a href="#autotoc_md69">Usability</a></li>
<li class="level2"><a href="#autotoc_md70">Asynchronous Model</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md71">More features</a><ul><li class="level2"><a href="#autotoc_md72">Real-time Tasks and Non-Real-time Tasks</a></li>
<li class="level2"><a href="#autotoc_md73">Asynchronous mode</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md74">Benchmark</a><ul><li class="level2"><a href="#autotoc_md75">System Configuration</a></li>
<li class="level2"><a href="#autotoc_md76">Test case</a><ul><li class="level3"><a href="#autotoc_md77">Peak QPS test</a></li>
<li class="level3"><a href="#autotoc_md78">ping-pong test</a></li>
<li class="level3"><a href="#autotoc_md79">long-tail test</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md80">Notes on benchmark test</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md81">Known Limitations</a></li>
</ul>
</div>
<div class="textblock"><ul>
<li>Introduction</li>
<li>Usability<ul>
<li>server</li>
<li>RPC with any parameters</li>
</ul>
</li>
<li>Compare with grpc/brpc<ul>
<li>Usability</li>
<li>Asynchronous Model</li>
</ul>
</li>
<li>More features<ul>
<li>Real-time Tasks and Non-Real-time Tasks</li>
<li>Asynchronous mode</li>
</ul>
</li>
<li>Benchmark<ul>
<li>System Configuration</li>
<li>Test case<ul>
<li>Peak QPS test</li>
<li>ping-pong test</li>
<li>long-tail test</li>
</ul>
</li>
<li>Notes on benchmark test</li>
</ul>
</li>
<li>Known Limitations</li>
</ul>
<p >coro_rpc is a high-performance Remote Procedure Call (RPC) framework in C++20, based on stackless coroutine and compile-time reflection. In an <code>echo</code> benchmark test on localhost, it reaches a peak QPS of 20 million, which exceeds other RPC libraries, such as grpc and brpc. Rather than high performance, the most key feature of coro_rpc is easy to use: as a header-only library, it does not need to be compiled or installed separately. It allows building an RPC client and server with a few lines of C++ code.</p>
<p >The core design goal of coro_rpc is usability. Instead of exposing too many troublesome details of the underlying RPC framework, coro_rpc provides a simplifying abstraction that allows programmers to concentrate principally on business logic and implement an RPC service without much effort. Given such simplicity, coro_rpc goes back to the essence of RPC: a remote function call similar to a normal function call except for the underlying network I/O. So coro_rpc user does not need to care about the underlying networking, data serialization, and so on but focus on up-layer implementations. And coro_rpc provides simple and straightforward APIs to users. Let's see one simple demo below</p>
<h1><a class="anchor" id="autotoc_md65"></a>
Usability</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
server</h2>
<ol type="1">
<li>define the RPC function</li>
</ol>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// rpc_service.hpp</div>
<div class="line">inline std::string echo(std::string str) { return str; }</div>
</div><!-- fragment --><ol type="1">
<li>register the RPC function and start the server</li>
</ol>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;rpc_service.hpp&quot;</div>
<div class="line">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  register_handler&lt;echo&gt;(); // register rpc function</div>
<div class="line"> </div>
<div class="line">  coro_rpc_server server(/*thread_num =*/10, /*port =*/9000);</div>
<div class="line">  server.start(); // start the server and blocking wait</div>
<div class="line">}</div>
</div><!-- fragment --><p >Basically one could build a RPC server in 5~6 lines by defining the rpc function and starting the server, without too much details to be worried about. Now let see how a RPC client works.</p>
<p >An RPC client has to connect to the server and then call the remote method.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;rpc_service.hpp&quot;</div>
<div class="line">#include &lt;coro_rpc/coro_rpc_client.hpp&gt;</div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; test_client() {</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">  co_await client.connect(&quot;localhost&quot;, /*port =*/&quot;9000&quot;);</div>
<div class="line"> </div>
<div class="line">  auto r = co_await client.call&lt;echo&gt;(&quot;hello coro_rpc&quot;); // call the method with parameters</div>
<div class="line">  std::cout &lt;&lt; r.result.value() &lt;&lt; &quot;\n&quot;; //will print &quot;hello coro_rpc&quot;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  syncAwait(test_client());</div>
<div class="line">}</div>
</div><!-- fragment --><p >As demonstrated above, it is also very convenient to build a client. There's not much difference between an RPC function call with a local function one: simply provides the function name and parameters.</p>
<p >The server/client implementation shows the usability and core features of coro_rpc. Also, it shows us the core concept of RPC: that users can invoke remote methods in a way with local functions, and users will focus their efforts on RPC functions.</p>
<p >Another usability of coro_rpc is that: there are barely any constraints on the RPC function itself. One could define an RPC function with any number of parameters of any type. The serialization/deserialization procedures are transparent to users and the RPC framework will take care of them automatically.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
RPC with any parameters</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// rpc_service.h</div>
<div class="line">// client needs to include this header and the implementation details are hidden </div>
<div class="line">void hello(){};</div>
<div class="line">int get_value(int a, int b){return a + b;}</div>
<div class="line"> </div>
<div class="line">struct person {</div>
<div class="line">  int id;</div>
<div class="line">  std::string name;</div>
<div class="line">  int age;</div>
<div class="line">};</div>
<div class="line">person get_person(person p, int id);</div>
<div class="line"> </div>
<div class="line">struct dummy {</div>
<div class="line">  std::string echo(std::string str) { return str; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// rpc_service.cpp</div>
<div class="line">#include &quot;rpc_service.h&quot;</div>
<div class="line"> </div>
<div class="line">int get_value(int a, int b){return a + b;}</div>
<div class="line"> </div>
<div class="line">person get_person(person p, int id) {</div>
<div class="line">  p.id = id;</div>
<div class="line">  return p;</div>
<div class="line">}</div>
</div><!-- fragment --><p >And in server, we define the following:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;rpc_service.h&quot;</div>
<div class="line">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  register_handler&lt;hello, get_value, get_person&gt;();//register the RPC functions of any signature </div>
<div class="line"> </div>
<div class="line">  dummy d{};</div>
<div class="line">  register_handler&lt;&amp;dummy::echo&gt;(&amp;d); //register the member functions</div>
<div class="line"> </div>
<div class="line">  coro_rpc_server server(/*thread_num =*/10, /*port =*/9000);</div>
<div class="line">  server.start(); // start the server</div>
<div class="line">}</div>
</div><!-- fragment --><p >In client, we have the following:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"># include &quot;rpc_service.h&quot;</div>
<div class="line"># include &lt;coro_rpc/coro_rpc_client.hpp&gt;</div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; test_client() {</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">  co_await client.connect(&quot;localhost&quot;, /*port =*/&quot;9000&quot;);</div>
<div class="line"> </div>
<div class="line">  //RPC invokes</div>
<div class="line">  co_await client.call&lt;hello&gt;();</div>
<div class="line">  co_await client.call&lt;get_value&gt;(1, 2);</div>
<div class="line"> </div>
<div class="line">  person p{};</div>
<div class="line">  co_await client.call&lt;get_person&gt;(p, /*id =*/1);</div>
<div class="line"> </div>
<div class="line">  auto r = co_await client.call&lt;&amp;dummy::echo&gt;(&quot;hello coro_rpc&quot;);</div>
<div class="line">  std::cout &lt;&lt; r.result.value() &lt;&lt; &quot;\n&quot;; //will print &quot;hello coro_rpc&quot;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  syncAwait(test_client());</div>
<div class="line">}</div>
</div><!-- fragment --><p> The input parameter and return type of <code>get_person</code> is a <code>struct</code>. The serialization/deserialization are automatically done by library <a href="/src/struct_pack/">struct_pack</a> with compile-time reflection. Users are not required to take efforts on such procedures.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Compare with grpc/brpc</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
Usability</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RPC   </th><th class="markdownTableHeadNone">Define DSL   </th><th class="markdownTableHeadNone">support coroutine   </th><th class="markdownTableHeadNone">code lines of hello world   </th><th class="markdownTableHeadNone">external dependency   </th><th class="markdownTableHeadNone">header-only    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">grpc   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">70+ <a href="https://github.com/grpc/grpc/tree/master/examples/cpp/helloworld">helloworld</a>   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">brpc   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">40+ <a href="https://github.com/apache/incubator-brpc/tree/master/example/asynchronous_echo_c%2B%2B">helloworld</a>   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">coro_rpc   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md70"></a>
Asynchronous Model</h2>
<p >Asynchronous callback VS. coroutine</p><ul>
<li>grpc asynchronous client</li>
</ul>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">//&lt;https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_callback_client.cc&gt;</div>
<div class="line">std::string SayHello(const std::string&amp; user) {</div>
<div class="line">    // Data we are sending to the server.</div>
<div class="line">    HelloRequest request;</div>
<div class="line">    request.set_name(user);</div>
<div class="line"> </div>
<div class="line">    // Container for the data we expect from the server.</div>
<div class="line">    HelloReply reply;</div>
<div class="line"> </div>
<div class="line">    // Context for the client. It could be used to convey extra information to</div>
<div class="line">    // the server and/or tweak certain RPC behaviors.</div>
<div class="line">    ClientContext context;</div>
<div class="line"> </div>
<div class="line">    // The actual RPC.</div>
<div class="line">    std::mutex mu;</div>
<div class="line">    std::condition_variable cv;</div>
<div class="line">    bool done = false;</div>
<div class="line">    Status status;</div>
<div class="line">    stub_-&gt;async()-&gt;SayHello(&amp;context, &amp;request, &amp;reply,</div>
<div class="line">                             [&amp;mu, &amp;cv, &amp;done, &amp;status](Status s) {</div>
<div class="line">                               status = std::move(s);</div>
<div class="line">                               std::lock_guard&lt;std::mutex&gt; lock(mu);</div>
<div class="line">                               done = true;</div>
<div class="line">                               cv.notify_one();</div>
<div class="line">                             });</div>
<div class="line"> </div>
<div class="line">    std::unique_lock&lt;std::mutex&gt; lock(mu);</div>
<div class="line">    while (!done) {</div>
<div class="line">      cv.wait(lock);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Act upon its status.</div>
<div class="line">    if (status.ok()) {</div>
<div class="line">      return reply.message();</div>
<div class="line">    } else {</div>
<div class="line">      std::cout &lt;&lt; status.error_code() &lt;&lt; &quot;: &quot; &lt;&lt; status.error_message()</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      return &quot;RPC failed&quot;;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><ul>
<li>brpc asynchronous client <div class="fragment"><div class="line"> {c++}</div>
<div class="line">// &lt;https://github.com/apache/incubator-brpc/blob/master/example/asynchronous_echo_c%2B%2B/client.cpp&gt;</div>
<div class="line">void HandleEchoResponse(</div>
<div class="line">        brpc::Controller*cntl,</div>
<div class="line">        example::EchoResponse* response) {</div>
<div class="line">    // std::unique_ptr makes sure cntl/response will be deleted before returning.</div>
<div class="line">    std::unique_ptr&lt;brpc::Controller&gt; cntl_guard(cntl);</div>
<div class="line">    std::unique_ptr&lt;example::EchoResponse&gt; response_guard(response);</div>
<div class="line"> </div>
<div class="line">    if (cntl-&gt;Failed()) {</div>
<div class="line">        LOG(WARNING) &lt;&lt; &quot;Fail to send EchoRequest, &quot; &lt;&lt; cntl-&gt;ErrorText();</div>
<div class="line">        return;</div>
<div class="line">    }</div>
<div class="line">    LOG(INFO) &lt;&lt; &quot;Received response from &quot; &lt;&lt; cntl-&gt;remote_side()</div>
<div class="line">        &lt;&lt; &quot;: &quot; &lt;&lt; response-&gt;message() &lt;&lt; &quot; (attached=&quot;</div>
<div class="line">        &lt;&lt; cntl-&gt;response_attachment() &lt;&lt; &quot;)&quot;</div>
<div class="line">        &lt;&lt; &quot; latency=&quot; &lt;&lt; cntl-&gt;latency_us() &lt;&lt; &quot;us&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">example::EchoService_Stub stub(&amp;channel);</div>
<div class="line"> </div>
<div class="line">    // Send a request and wait for the response every 1 second.</div>
<div class="line">    int log_id = 0;</div>
<div class="line">    while (!brpc::IsAskedToQuit()) {</div>
<div class="line">        // Since we are sending asynchronous RPC (`done&#39; is not NULL),</div>
<div class="line">        // these objects MUST remain valid until `done&#39; is called.</div>
<div class="line">        // As a result, we allocate these objects on heap</div>
<div class="line">        example::EchoResponse* response = new example::EchoResponse();</div>
<div class="line">        brpc::Controller* cntl = new brpc::Controller();</div>
<div class="line"> </div>
<div class="line">        // Notice that you don&#39;t have to new request, which can be modified</div>
<div class="line">        // or destroyed just after stub.Echo is called.</div>
<div class="line">        example::EchoRequest request;</div>
<div class="line">        request.set_message(&quot;hello world&quot;);</div>
<div class="line"> </div>
<div class="line">        cntl-&gt;set_log_id(log_id ++);  // set by user</div>
<div class="line">        if (FLAGS_send_attachment) {</div>
<div class="line">            // Set attachment which is wired to network directly instead of </div>
<div class="line">            // being serialized into protobuf messages.</div>
<div class="line">            cntl-&gt;request_attachment().append(&quot;foo&quot;);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        // We use protobuf utility `NewCallback&#39; to create a closure object</div>
<div class="line">        // that will call our callback `HandleEchoResponse&#39;. This closure</div>
<div class="line">        // will automatically delete itself after being called once</div>
<div class="line">        google::protobuf::Closure* done = brpc::NewCallback(</div>
<div class="line">            &amp;HandleEchoResponse, cntl, response);</div>
<div class="line">        stub.Echo(cntl, &amp;request, response, done);</div>
<div class="line"> </div>
<div class="line">        // This is an asynchronous RPC, so we can only fetch the result</div>
<div class="line">        // inside the callback</div>
<div class="line">        sleep(1);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>coro_rpc client with coroutine</li>
</ul>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"># include &lt;coro_rpc/coro_rpc_client.hpp&gt;</div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; say_hello(){</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">    co_await client.connect(&quot;localhost&quot;, /*port =*/&quot;9000&quot;);</div>
<div class="line">  while (true){</div>
<div class="line">    auto r = co_await client.call&lt;echo&gt;(&quot;hello coro_rpc&quot;);</div>
<div class="line">    assert(r.result.value() == &quot;hello coro_rpc&quot;);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >One core feature of coro_rpc is stackless coroutine where users could write asynchronous code in a synchronous manner, which is more simple and easy to understand.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
More features</h1>
<h2><a class="anchor" id="autotoc_md72"></a>
Real-time Tasks and Non-Real-time Tasks</h2>
<p >The examples shown earlier do not demonstrate how responses are sent back to the client with the results, because by default the coro_rpc framework will help the user to serialize and send the results to client automatically. And the user is completely unaware and only needs to focus on the business logic. It should be noted that, in this scenario, the response callback is executed in the I/O thread, which is suitable for real-time critical scenarios, with the disadvantage of blocking the I/O thread. What if the user does not want to execute the business logic in the io thread, but rather in a thread or thread pool and delays sending messages?</p>
<p >coro_rpc has taken this problem into account. coro_rpc considers that RPC tasks are divided into real-time and Non-real-time tasks. real-time tasks are executed in the I/O thread and sent to the client immediately, with better timeliness and lower latency; Non-real-time tasks can be scheduled in a separate thread, and the requests are sent to the server at some point in the future; coro_rpc supports both kinds of tasks.</p>
<p >Switch to time-delayed task</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;coro_rpc/connection.hpp&gt;</div>
<div class="line">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</div>
<div class="line"> </div>
<div class="line">//Real-time tasks</div>
<div class="line">std::string echo(std::string str) { return str; }</div>
<div class="line"> </div>
<div class="line">//Non-Real-time tasks, requests handled in separate thread</div>
<div class="line">void delay_echo(coro_connection&lt;std::string&gt; conn, std::string str) {</div>
<div class="line">  std::thread([conn, str]{</div>
<div class="line">    conn.response_msg(str); //requests handled in separate thread</div>
<div class="line">  }).detach();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
Asynchronous mode</h2>
<p >It is recommended to use coroutine on server development. However, the asynchronous call mode is also supported if user does not prefer coroutine.</p>
<ul>
<li>coroutine based rpc server <div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</div>
<div class="line">std::string hello() { return &quot;hello coro_rpc&quot;; }</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  register_handler&lt;hello, echo&gt;();</div>
<div class="line">  coro_rpc_server server(/*thread_num =*/10, /*port =*/9000);</div>
<div class="line">  server.start();</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Asynchronous rpc server</li>
</ul>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;coro_rpc/async_rpc_server.hpp&gt;</div>
<div class="line">std::string hello() { return &quot;hello coro_rpc&quot;; }</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  register_handler&lt;hello, echo&gt;();</div>
<div class="line">  async_rpc_server server(/*thread_num =*/10, /*port =*/9000);</div>
<div class="line">  server.start();</div>
<div class="line">}</div>
</div><!-- fragment --><p >Compile-time syntax checks coro_rpc does a compile-time check on the legality of the arguments when it is called, e.g.:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">inline std::string echo(std::string str) { return str; }</div>
</div><!-- fragment --><p >When client is called via:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">client.call&lt;echo&gt;(42);    //Parameter mismatch, compile error</div>
<div class="line">client.call&lt;echo&gt;();      //Missing parameters, compile error</div>
<div class="line">client.call&lt;echo&gt;(&quot;&quot;, 0); //Redundant parameters, compile error</div>
<div class="line">client.call&lt;echo&gt;(&quot;hello, coro_rpc&quot;);//Parameters match, OK</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md74"></a>
Benchmark</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
System Configuration</h2>
<p >Processor：Intel(R) Xeon(R) Platinum 8163 CPU @2.50GHz 96Cores</p>
<p >OS: Linux version 4.9.151-015.ali3000.alios7.x86_64</p>
<p >Compiler：Alibaba Clang13 C++20</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Test case</h2>
<p >Both the client and server are on the same machine, sending requests using different amounts of connections to do echo tests.</p>
<h3><a class="anchor" id="autotoc_md77"></a>
Peak QPS test</h3>
<ol type="1">
<li>Send data and receive data through a pipeline, put CPU under full load and get the highest qps <br  />
 <img src="max_qps.png" alt="" class="inline" title="max_qps"/>    </li>
</ol>
<h3><a class="anchor" id="autotoc_md78"></a>
ping-pong test</h3>
<ol type="1">
<li>send the next request after the previous one is completed</li>
<li>check the QPS as the number of connections increases.</li>
<li>get the average latency of ping-pong <br  />
 <img src="pingpong_qps.png" alt="" class="inline" title="ping_pong_qps"/>     <img src="pingpong_time.png" alt="" class="inline" title="pingpong_time"/>    </li>
</ol>
<h3><a class="anchor" id="autotoc_md79"></a>
long-tail test</h3>
<p ><img src="long_tail_qps.png" alt="" class="inline" title="long_tail_qps"/>     <img src="long_tail_time.png" alt="" class="inline" title="long_tail_time"/>    </p>
<h2><a class="anchor" id="autotoc_md80"></a>
Notes on benchmark test</h2>
<ol type="1">
<li>grpc's QPS does not exceed 100,000, so it is not included in this benchmarking.</li>
<li>The client is a coro_rpc based client for both coro_rpc and brpc stress test. It has better stress test performance compared to a brpc client(With a brpc client, the brpc client will drop 50%).</li>
<li>brpc uses connection multiplexing, The actual number of socket connections is not that high(96)</li>
</ol>
<h1><a class="anchor" id="autotoc_md81"></a>
Known Limitations</h1>
<ol type="1">
<li>Only little-endian is supported for now. Big-endian is working in progress</li>
<li>Only C++ is supported and could not work across languages now, will support other languages later; Compiler should support C++20(clang13, gcc10.2, msvc2022)</li>
<li>If any compile issue with <code>gcc -O3</code>, please try option <code>-fno-tree-slp-vectorize</code> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
